---
title: "Crafting Prompts in Node.js/TypeScript with Structure"
shortTitle: "littleprompt"
slug: "/nodejs-typescript-structured-prompts"
category: ""
color: "#ffffff"
date: "2025-06-19"
description: Learn how to build effective, structured prompts for LLMs in Node.js and TypeScript using a modern, chainable approach. Improve your AI prompt engineering workflow with best practices and code examples.
tags: [nodejs, typescript, prompt-engineering, llm, ai, openai, developer-tools, mdx, prompt-library, gpt, chatgpt, prompt-design, software-engineering, code-examples, productivity, best-practices]
keywords: [prompt engineering, node.js, typescript, LLM, openai, gpt, chatgpt, ai, developer tools, prompt library, structured prompts, chainable api, code examples, best practices, productivity, software engineering]
---

Prompt engineering is quickly becoming a core skill for developers working with large language models (LLMs) like OpenAI's GPT, Anthropic's Claude, and others. But as your projects grow, so does the complexity of your prompts. Messy string concatenation, scattered instructions, and unclear formatting can make your codebase hard to maintain and your AI outputs unpredictable.

In this post, you'll learn how to build robust, maintainable prompts for LLMs in Node.js and TypeScript using a modern, chainable approach. We'll cover best practices, code examples, and a tiny library that makes prompt design easier for developers.

## Why Structured Prompts for LLMs?

- **Clarity:** Well-structured prompts lead to more predictable and accurate LLM responses.
- **Reusability:** Modular prompt components (like personas, tones, and formatting rules) can be reused across your codebase.
- **Maintainability:** Chainable APIs and object-based instructions are easier to update and reason about than long, concatenated strings.
- **Type Safety:** TypeScript support ensures your prompt logic is robust and less error-prone.

## Meet `littleprompt`: A Chainable Prompt Library for Node.js/TypeScript

[`littleprompt`](https://www.npmjs.com/package/littleprompt) is a tiny, chainable Node.js/TypeScript library designed to help you build effective and structured prompts by incrementally adding instructions. It‚Äôs not magic, but it will make your prompt engineering workflow a lot more enjoyable.

### Installation

```bash
npm install littleprompt
```

## Building Prompts: The Chainable Way

Instead of concatenating strings, you can chain together system instructions, modifiers, and user queries:

```typescript
import prompt from "littleprompt";

// Chain system instructions, modifiers, and the user's query together.
const myPrompt = prompt
  .system({ type: "engineer", name: "Johnson" }) // Start with an object
  .concise()
  .truthful()
  .system("is funny") // Add more instructions as a string
  .system({ responseType: "structuredJSON" }) // Even add formatting rules
  .user("What are the first 3 steps to making a website?"); // Finally, add the user's question

console.log(myPrompt.build());
```

**Resulting Prompt:**

```
System: 
  Your name: Johnson <--- Use this name at all times
  Role: Engineer
  Context of role:
    An engineer is a professional who applies scientific and mathematical principles to design, develop, and innovate solutions to practical problems. Engineers are involved in inventing, designing and maintaining a variety of machines, structures and data systems. They are experts in their fields, creating and innovating constantly. Engineers use their expertise in various branches of engineering, such as civil, mechanical, electrical, chemical, or software engineering, to create, improve, and maintain systems, structures, processes, and technologies.
  Instruction: Your answers must be concise. If you do not know the answer, say so. 
  Instruction: Your personality is funny. 
  Response Type: You must structure your response as a JSON data type.
  JSON Response Structure: {}

User: What are the first 3 steps to making a website?
```

## Key Features for Developers

### 1. Chainable System Instructions

Add as many system instructions as you need, using either strings or objects:

```typescript
prompt
  .system("You are a helpful assistant.")
  .system({ persona: "Shakespearean poet", mood: "dramatic" });
```

### 2. User Queries and Problem Statements

Set the user's question or problem:

```typescript
prompt
  .system("You are a world-class chef.")
  .user("How do I make a perfect omelette?");
```

### 3. One-Liner Modifiers

Handy shortcuts for common instructions:

- `.concise()`: Short, to-the-point answers.
- `.detailed()`: Comprehensive, detailed responses.
- `.truthful()`: Admit when you don't know.
- `.json(schema)`: Ask for a JSON response, optionally with a schema.
- `.mood(feeling)`: Set the tone, e.g., `.mood("funny")`.
- `.expert(field)`: Act as an expert, e.g., `.expert("quantum physics")`.

### 4. Reusable Personas

Create reusable prompt chains for consistent personas:

```typescript
import prompt, { type Prompt } from "littleprompt";

const GrumpyReviewer = () => {
  return prompt
    .system({ persona: "Senior Engineer", role: "Code Reviewer" })
    .mood("incredibly grumpy")
    .concise();
};

const reviewPrompt = GrumpyReviewer()
  .user("Please review my amazing new function that sorts an array using bubble sort.")
  .build();

console.log(reviewPrompt);
```

## Try It Yourself: Node.js & TypeScript Prompt Engineering Examples

Check out the [`examples/`](./examples) directory in the repo for ready-to-run Node.js and TypeScript code samples that show how to:

- Build prompts for OpenAI, Anthropic, and other LLM APIs
- Use chainable prompt logic in real-world projects
- Apply best practices for maintainable, readable prompt code

---

Prompt engineering doesn't have to be messy. With a structured, chainable approach, you can build powerful, maintainable prompts that get the best out of today's LLMs‚Äîright from your Node.js or TypeScript project.

Happy prompting! ü§è
